import numpy as np
from typing import List, Dict, Any
from SimulationEngine import SimulationResult
from Config import SimulationConfig
from Optimizer import PistonSpec


class EvaluationEngine:
    """
    Ranks configurations based on how close they are to hardcoded
    user effort targets (in Newtons).
    """

    def __init__(self,
                 target_close_force_n: float = 20.0,
                 target_open_force_n: float = 10.0):
        """
        :param target_close_force_n: Desired force to pull the door shut (at 0Â°).
        :param target_open_force_n: Desired force to lift the door (at mid-range).
        """
        self.target_close_force = target_close_force_n
        self.target_open_force = target_open_force_n

        # Scoring weights
        self.weights = {
            "hinge_stress": 0.2,
            "close_accuracy": 0.4,
            "open_accuracy": 0.4
        }

    def _get_user_force_at_handle(self, net_torque: float, door_length: float) -> float:
        """
        Converts net torque (Nm) to the linear force (N) a user feels at the handle.
        Force = Torque / Distance
        """
        return net_torque / door_length

    def calculate_metrics(self, result: SimulationResult, cfg: SimulationConfig) -> Dict[str, float]:
        actual_close_force = abs(self._get_user_force_at_handle(result.net_torques[0], cfg.door_length))

        positive_torques = [t for t in result.net_torques if t > 0]
        avg_positive_torque = np.mean(positive_torques) if positive_torques else 0.0
        actual_open_force = self._get_user_force_at_handle(avg_positive_torque, cfg.door_length)

        # 3. Maximum Hinge Stress
        max_hinge_force = max(result.hinge_forces)

        return {
            "actual_close_force": actual_close_force,
            "actual_open_force": actual_open_force,
            "max_hinge_force": max_hinge_force
        }


#Generated by AI, not sure if this is the way scoring should be done
    def score_solution(self, metrics: Dict[str, float]) -> float:
        # Score Closing Accuracy: 1.0 is a perfect match, drops as it deviates
        close_diff = abs(metrics["actual_close_force"] - self.target_close_force)
        s_close = max(0.0, 1 - (close_diff / 50.0))  # 0 score if >50N away from target

        # Score Opening Accuracy: 1.0 is a perfect match
        open_diff = abs(metrics["actual_open_force"] - self.target_open_force)
        s_open = max(0.0, 1 - (open_diff / 50.0))

        # Score Hinge Stress: Penalty if force is extremely high (> 2500N)
        s_hinge = max(0.0, 1 - (metrics["max_hinge_force"] / 2500.0))

        return (s_close * self.weights["close_accuracy"] +
                s_open * self.weights["open_accuracy"] +
                s_hinge * self.weights["hinge_stress"])

    def evaluate_all(self,
                     solutions: List[Dict[str, Any]],
                     base_cfg: SimulationConfig) -> List[Dict[str, Any]]:
        for sol in solutions:
            metrics = self.calculate_metrics(sol['result'], base_cfg)
            sol['score'] = self.score_solution(metrics)
            sol['metrics'] = metrics

            # Diagnostic Info
            sol['summary'] = (f"Close Force: {metrics['actual_close_force']:.1f}N "
                              f"(Target: {self.target_close_force}N), "
                              f"Open Force: {metrics['actual_open_force']:.1f}N "
                              f"(Target: {self.target_open_force}N)")

        return sorted(solutions, key=lambda x: x['score'], reverse=True)